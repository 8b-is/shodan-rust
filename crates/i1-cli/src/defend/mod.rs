//! Defense module: geo-blocking, IP banning, firewall rule generation.

use anyhow::Result;
use directories::ProjectDirs;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Defense state - what's currently blocked.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct State {
    /// Blocked country codes (ISO 2-letter, lowercase) - inbound.
    pub blocked_countries: Vec<String>,

    /// Blocked country codes for outbound traffic (ISO 2-letter, lowercase).
    /// Lets attackers connect in (natural honeypot) but blocks responses going out.
    #[serde(default)]
    pub blocked_countries_outbound: Vec<String>,

    /// Blocked IP addresses and CIDR ranges.
    pub blocked_ips: Vec<String>,

    /// Blocked AS numbers (e.g., "AS12345").
    pub blocked_asns: Vec<String>,

    /// Whitelisted IPs (never blocked, including outbound).
    pub whitelisted_ips: Vec<String>,
}

impl State {
    /// Get the state file path.
    pub fn path() -> Result<PathBuf> {
        let dirs = ProjectDirs::from("is", "i1", "showdi1")
            .ok_or_else(|| anyhow::anyhow!("Could not determine config directory"))?;

        Ok(dirs.data_dir().join("defend_state.json"))
    }

    /// Load state from file.
    pub fn load() -> Result<Self> {
        let path = Self::path()?;

        if !path.exists() {
            return Ok(Self::default());
        }

        let content = std::fs::read_to_string(&path)?;
        let state: Self = serde_json::from_str(&content)?;

        Ok(state)
    }

    /// Save state to file.
    pub fn save(&self) -> Result<()> {
        let path = Self::path()?;

        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(&path, content)?;

        Ok(())
    }
}

/// Geo-blocking operations.
pub struct GeoBlock;

/// IP set operations.
pub struct IpSet;

/// Get country name from code.
pub fn country_name(code: &str) -> &'static str {
    match code.to_lowercase().as_str() {
        "cn" => "China",
        "ru" => "Russia",
        "us" => "United States",
        "ro" => "Romania",
        "pl" => "Poland",
        "kz" => "Kazakhstan",
        "ua" => "Ukraine",
        "vn" => "Vietnam",
        "br" => "Brazil",
        "in" => "India",
        "kr" => "South Korea",
        "de" => "Germany",
        "fr" => "France",
        "gb" | "uk" => "United Kingdom",
        "jp" => "Japan",
        "nl" => "Netherlands",
        "th" => "Thailand",
        "id" => "Indonesia",
        "ca" => "Canada",
        "au" => "Australia",
        "mx" => "Mexico",
        "it" => "Italy",
        "es" => "Spain",
        "ar" => "Argentina",
        "eg" => "Egypt",
        "za" => "South Africa",
        "ng" => "Nigeria",
        "pk" => "Pakistan",
        "bd" => "Bangladesh",
        "ph" => "Philippines",
        "my" => "Malaysia",
        "sg" => "Singapore",
        "hk" => "Hong Kong",
        "tw" => "Taiwan",
        "ir" => "Iran",
        "kp" => "North Korea",
        _ => "Unknown",
    }
}

/// Generate nftables rules from state.
pub fn generate_nftables(state: &State) -> Result<String> {
    let mut rules = String::new();

    rules.push_str("#!/usr/sbin/nft -f\n");
    rules.push_str("# Generated by showdi1 defend export\n");
    rules.push_str("# Apply with: nft -f <filename>\n\n");

    rules.push_str("table inet geoblock {\n");

    // Whitelist set
    if !state.whitelisted_ips.is_empty() {
        rules.push_str("    set whitelist {\n");
        rules.push_str("        type ipv4_addr\n");
        rules.push_str("        flags interval\n");
        rules.push_str("        elements = { ");
        rules.push_str(&state.whitelisted_ips.join(", "));
        rules.push_str(" }\n");
        rules.push_str("    }\n\n");
    }

    // Blocked IPs set
    if !state.blocked_ips.is_empty() {
        rules.push_str("    set blocked_ips {\n");
        rules.push_str("        type ipv4_addr\n");
        rules.push_str("        flags interval\n");
        rules.push_str("        elements = { ");
        rules.push_str(&state.blocked_ips.join(", "));
        rules.push_str(" }\n");
        rules.push_str("    }\n\n");
    }

    // Country sets (placeholder - would need IP ranges)
    for country in &state.blocked_countries {
        rules.push_str(&format!(
            "    # Country: {} ({})\n",
            country.to_uppercase(),
            country_name(country)
        ));
        rules.push_str(&format!("    # Download ranges from: https://www.ipdeny.com/ipblocks/data/aggregated/{country}-aggregated.zone\n"));
        rules.push_str(&format!("    set country_{country} {{\n"));
        rules.push_str("        type ipv4_addr\n");
        rules.push_str("        flags interval\n");
        rules.push_str("        # elements = { ... load from zone file ... }\n");
        rules.push_str("    }\n\n");
    }

    // Outbound country sets
    for country in &state.blocked_countries_outbound {
        if !state.blocked_countries.contains(country) {
            rules.push_str(&format!(
                "    # Country (outbound): {} ({})\n",
                country.to_uppercase(),
                country_name(country)
            ));
            rules.push_str(&format!("    # Download ranges from: https://www.ipdeny.com/ipblocks/data/aggregated/{country}-aggregated.zone\n"));
            rules.push_str(&format!("    set country_{country} {{\n"));
            rules.push_str("        type ipv4_addr\n");
            rules.push_str("        flags interval\n");
            rules.push_str("        # elements = { ... load from zone file ... }\n");
            rules.push_str("    }\n\n");
        }
    }

    // Input chain
    rules.push_str("    chain input {\n");
    rules.push_str("        type filter hook input priority 0; policy accept;\n\n");

    // Whitelist rule
    if !state.whitelisted_ips.is_empty() {
        rules.push_str("        # Allow whitelisted IPs\n");
        rules.push_str("        ip saddr @whitelist accept\n\n");
    }

    // Block rules
    if !state.blocked_ips.is_empty() {
        rules.push_str("        # Block specific IPs\n");
        rules.push_str("        ip saddr @blocked_ips drop\n\n");
    }

    for country in &state.blocked_countries {
        rules.push_str(&format!("        # Block {}\n", country_name(country)));
        rules.push_str(&format!("        ip saddr @country_{country} drop\n"));
    }

    rules.push_str("    }\n\n");

    // Output chain - outbound blocking (honeypot mode)
    if !state.blocked_countries_outbound.is_empty() {
        rules.push_str("    chain output {\n");
        rules.push_str("        type filter hook output priority 0; policy accept;\n\n");

        // Always allow outbound to whitelisted IPs
        if !state.whitelisted_ips.is_empty() {
            rules.push_str("        # Always allow outbound to whitelisted IPs\n");
            rules.push_str("        ip daddr @whitelist accept\n\n");
        }

        for country in &state.blocked_countries_outbound {
            rules.push_str(&format!(
                "        # Block outbound to {} (honeypot mode)\n",
                country_name(country)
            ));
            rules.push_str(&format!("        ip daddr @country_{country} drop\n"));
        }

        rules.push_str("    }\n");
    }

    rules.push_str("}\n");

    Ok(rules)
}

/// Generate iptables rules from state.
pub fn generate_iptables(state: &State) -> Result<String> {
    let mut rules = String::new();

    rules.push_str("#!/bin/bash\n");
    rules.push_str("# Generated by showdi1 defend export\n");
    rules.push_str("# Run as root to apply\n\n");

    rules.push_str("# Create chain\n");
    rules.push_str("iptables -N GEOBLOCK 2>/dev/null || iptables -F GEOBLOCK\n\n");

    // Whitelist
    for ip in &state.whitelisted_ips {
        rules.push_str(&format!(
            "# Whitelist\niptables -A GEOBLOCK -s {ip} -j ACCEPT\n"
        ));
    }

    if !state.whitelisted_ips.is_empty() {
        rules.push('\n');
    }

    // Block IPs
    for ip in &state.blocked_ips {
        rules.push_str(&format!("iptables -A GEOBLOCK -s {ip} -j DROP\n"));
    }

    // Country blocks (placeholder)
    for country in &state.blocked_countries {
        rules.push_str(&format!(
            "\n# Block {} ({})\n",
            country_name(country),
            country.to_uppercase()
        ));
        rules.push_str(&format!("# Download: curl -s https://www.ipdeny.com/ipblocks/data/aggregated/{country}-aggregated.zone | while read ip; do\n"));
        rules.push_str("#   iptables -A GEOBLOCK -s $ip -j DROP\n");
        rules.push_str("# done\n");
    }

    rules.push_str("\n# Insert chain into INPUT\n");
    rules.push_str("iptables -I INPUT -j GEOBLOCK\n");

    // Outbound blocking (honeypot mode)
    if !state.blocked_countries_outbound.is_empty() {
        rules.push_str("\n# ── Outbound blocking (honeypot mode) ──\n");
        rules.push_str("# They can connect in, but nothing goes back out.\n");
        rules.push_str("iptables -N GEOBLOCK_OUT 2>/dev/null || iptables -F GEOBLOCK_OUT\n\n");

        // Always allow outbound to whitelisted IPs
        for ip in &state.whitelisted_ips {
            rules.push_str(&format!(
                "# Whitelist outbound\niptables -A GEOBLOCK_OUT -d {ip} -j ACCEPT\n"
            ));
        }
        if !state.whitelisted_ips.is_empty() {
            rules.push('\n');
        }

        for country in &state.blocked_countries_outbound {
            rules.push_str(&format!(
                "\n# Block outbound to {} ({})\n",
                country_name(country),
                country.to_uppercase()
            ));
            rules.push_str(&format!("# Download: curl -s https://www.ipdeny.com/ipblocks/data/aggregated/{country}-aggregated.zone | while read ip; do\n"));
            rules.push_str("#   iptables -A GEOBLOCK_OUT -d $ip -j DROP\n");
            rules.push_str("# done\n");
        }

        rules.push_str("\n# Insert chain into OUTPUT\n");
        rules.push_str("iptables -I OUTPUT -j GEOBLOCK_OUT\n");
    }

    Ok(rules)
}

/// Generate pf rules for BSD/macOS.
pub fn generate_pf(state: &State) -> Result<String> {
    let mut rules = String::new();

    rules.push_str("# Generated by showdi1 defend export\n");
    rules.push_str("# Add to /etc/pf.conf and run: pfctl -f /etc/pf.conf\n\n");

    // Tables
    if !state.whitelisted_ips.is_empty() {
        rules.push_str("table <whitelist> { ");
        rules.push_str(&state.whitelisted_ips.join(", "));
        rules.push_str(" }\n");
    }

    if !state.blocked_ips.is_empty() {
        rules.push_str("table <blocked> { ");
        rules.push_str(&state.blocked_ips.join(", "));
        rules.push_str(" }\n");
    }

    for country in &state.blocked_countries {
        rules.push_str(&format!(
            "# table <{country}> {{ ... load from {country}-aggregated.zone ... }}\n"
        ));
    }

    rules.push_str("\n# Rules\n");

    if !state.whitelisted_ips.is_empty() {
        rules.push_str("pass in quick from <whitelist>\n");
    }

    if !state.blocked_ips.is_empty() {
        rules.push_str("block in quick from <blocked>\n");
    }

    for country in &state.blocked_countries {
        rules.push_str(&format!("# block in quick from <{country}>\n"));
    }

    // Outbound blocking (honeypot mode)
    if !state.blocked_countries_outbound.is_empty() {
        rules.push_str("\n# ── Outbound blocking (honeypot mode) ──\n");
        rules.push_str("# They can connect in, but nothing goes back out.\n");

        if !state.whitelisted_ips.is_empty() {
            rules.push_str("pass out quick to <whitelist>\n");
        }

        for country in &state.blocked_countries_outbound {
            rules.push_str(&format!(
                "# block out quick to <{country}>  # {} - honeypot\n",
                country_name(country)
            ));
        }
    }

    Ok(rules)
}
